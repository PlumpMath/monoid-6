<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>reveal.js - The HTML Presentation Framework</title>

		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
		<meta name="author" content="Hakim El Hattab">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/default.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', use the PDF print sheet -->
		<script>
			document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h1>La puissance de mon Monoïde est supérieure à 9000</h1>
					<img src="images/magma.jpg" alt="magma"/>
				</section>


				<section>
					<h2>Qu'est ce qu'un monoide&nbsp;?</h2>
					<p class="fragment">Un monoïde est <strong>un magma unifère associatif</strong></p>
					<h2 class="fragment">Non, en vrai, c'est quoi un monoïde&nbsp;?</h2>					
				</section>

				<section>
					<h1>Laissez moi vous raconter une histoire...</h1>					
				</section>

				<section>
					 
					<h3 >Il était une fois,</h3 > 
						
					<img src="images/boo.jpg" alt="boo" class="fragment" />
					<aside class="notes">
							dans un monde où les problèmes se réglent à coup de poing,
							un grand méchant nommé Boo voulant détruire la Terre débarque
					</aside>
				</section>

				<section>
					<h3>Pour cette démonstration,<br /> utilisons <a href="http://www.typescriptlang.org/">TypeScript</a> &nbsp;:</h3>
					<ul>
						<li class="fragment">Syntaxe proche de JavaScript</li>
						<li class="fragment">Sucre syntaxique et classes</li>
						<li class="fragment">Typage statique</li>
						<li class="fragment">Langage cool</li>
					</ul>
					<aside class="notes">
						<ul>
							<li>Lisible par les non initiés</li>
						</ul>
					</aside>
				</section>

				<section>
					<h3>Modélisons Boo</h3>
					<pre><code>
class Guy {		
    constructor(public power:number) {}

    //Égalité structurelle
    equals(g:Guy): boolean {    	
    	return g.power == this.power
    }
}

var boo = new Guy(8500)
console.log(boo.power) //affiche 8500
					</code></pre>
					<aside class="notes">
						JavaScript n'a pas de surcharge de ==
					</aside>
				</section>

				<section>
					<h2>Mais la Terre est fournie avec un protecteur infatiguable&nbsp;!</h2>

					<img src="images/goku_biting_boo.gif" class="fragment"/>

					<aside class="notes">
						Et parce qu'on comprend mieux<br /> la différence entre le bien et le mal avec le visage tuméfié,<br /> Goku va se battre&nbsp;!
					</aside>
				</section>

				
				<section>
					<h3>Modélisons goku et le combat</h3>
					<pre><code>
var boo = new Guy(8500);
var goku = new Guy(4000)

var fight = function (guy1:Guy, guy2:Guy):Guy {	
	return guy1.power > guy2.power ? guy1 : guy2
}

var winner = fight(goku, boo)
console.log(winner) // affiche boo, car il est de loin de le plus fort
					</code></pre>
				</section>

				<section>
					<h2>Goku a perdu&nbsp;!</h2>
					<img src="images/GokuInjured.png" />
					<aside class="notes">
						Ci-dessous, Goku philosophe sur le problème du mal
					</aside>
				</section>

				<section>
					<h2>Appel à un ami</h2>
					<img src="images/VegetaPotara.png" />
					<aside class="notes">
						Puis ce que Boo refuse d'entendre raison, Goku fait appel à un ami et décide d'utiliser la technique secrète de fusion.<br />
						Vegeta est un brave gars qui a bien compris qui étaient les gentils et qu'ils valaient mieux accepter leurs propositions 
						si on ne voulait pas finir avec l'oeil couleur tunique
					</aside>

				</section>


				<section>
					<h3>Modélisons la fusion</h3>
					<pre><code>
var boo = new Guy(8500);
var goku = new Guy(4000)
var vegeta = new Guy(3900);

var fusion = function(guy1:Guy, guy2:Guy):Guy {
 		return new Guy(guy1.power + guy2.power);
}

var bejito = fusion(goku, vegeta); 
console.log(bejito.power) // affiche 7900

var winner = fight(bejito, boo)
console.log(winner) // affiche toujours boo, car il est toujours le plus fort
					</code></pre>
				</section>

				<section>
					<h2>Bejito est vaincu&nbsp;!</h2>
					<img src="images/BejitoCandy.png" />
				</section>

				<section>
					<h2>Augmentons le nombre de ressource</h2>
					<img src="images/gotenksFusion.png" />
					<aside class="notes">
						Tous les chefs de projet le savent, si ca ne marche pas à 2, il suffit d'augmenter la taille de l'équipe
					</aside>			
				</section>

				<section>
					<h3>Fusion partout&nbsp;!</h3>
					<pre><code>
var goten = new Guy(2000)
var trunks = new Guy(2500)

var gotenks = fusion(goten, trunks)
console.log(gotenks.power) // affiche 4500

var gobejitenks = fusion(gotenks, bejito) 
console.log(gobejitenks) // affiche 12400

fight(gobejitenks, boo) // gobejitenks gagne
</code></pre>
				</section>

				<section>
					<h2>Gobejitenks gagne</h2>
					<img src="images/its-over-9000.gif" />
				</section>

				<section>
					<h1>Que nous montre cet exemple&nbsp;?</h1>
				</section>

				<section>
					<h3>Loi de composition interne</h3>
					
					<pre><code>var fusion = function(guy1:Guy, guy2:Guy):Guy {
 		return new Guy(guy1.power + guy2.power);
}</code></pre>
					
					<ul>
						<li class="fragment"><code>fusion</code> est une fonction...</li>
						<li class="fragment">...qui prend 2 paramètres du même type <code>Guy</code></li>
						<li class="fragment">...qui renvoit une valeur du même type <code>Guy</code></li>
					</ul>					
				</section>

				<section>
					<h3>Associativité</h3>
					<pre class="fragment"><code>
var fusion = function(guy1:Guy, guy2:Guy):Guy {
 		return new Guy(guy1.power + guy2.power);
}			

var fusionned1 = fusion(fusion(goku, vegeta), goten)
var fusionned2 =  fusion(goku, fusion(vegeta, goten))
console.log(fusionned1.equals(fusionned2)) //affiche true

</code></pre>		
				</section>

				<section>
					<h3>Les lois de composition interne associative<br /> permettent généralement de rendre plus lisible <br />
						les <code>fold</code>/<code>inject</code>/<code>reduce</code>
					</h3>
					<pre><code>var gobejitenks = [goku, vegeta, goten, trunks].reduce(fusion)</code></pre>
				</section>

				<section>
					<h2>Élement neutre</h2>

					<img class="fragment" src="images/GokuMr.SatanMX.png" />
					<aside class="notes">
						On notera quand même que parfois la fusion ca marche pas top
					</aside>
				</section>

				<section>
					<h3> élèment neutre de <code>fusion</code>&nbsp;:</h3>
					
					<pre><code>
var goku = new Guy(4000)
var mrSatan = new Guy(0)

var gotan = fusion(goku, mrSatan)
var saku = gusion(mrSatan, goku)

console.log(gotan.equals(saku)) //affiche true
console.log(gotan.equals(goku)) //affiche true
console.log(saku.equals(goku)) //affiche true
					</code></pre>
				</section>

				<section>
					<h2>On a un monoïde&nbsp;!</h2>
					<p class="fragment">Un monoide est un <strong>ensemble</strong> muni d'une <strong>loi de composition interne associative</strong> et d'un <strong>élément neutre</strong></p>
					<ul>
						<li class="fragment">Ensemble des <code>Guy</code></li>
						<li class="fragment"><code>fusion</code></li>
						<li class="fragment"><code>new Guy(0)</code></li>
					</ul>
				</section>

				<section>
					<h1>ET&nbsp;?</h1>
					<h2 class="fragment">À quoi ca sert&nbsp;?</h2>
					<aside class="notes">Complexifions l'exemple</aside>
				</section>

				<section>
					<h1>La fusion,<br /> ça prend du temps</h1>				
					<img src="images/fusionDanse.gif" />
					<aside class="notes">
						Il faut faire une petite danse ridicule
					</aside>
				</section>
				
				<section>
						<h2><a href="https://github.com/kriskowal/q">Q</a>, librairie de promesse</h2>
						<ul>
							<li class="fragment">Execution séquentielle de code asynchrone</li>
							<li class="fragment">composabilité</li>	
							<li class="fragment">Les promesses, c'est cool</li>							
						</ul>
				</section>

				<section>
					<h3><code>fusion</code> différée</h3>
					<pre><code>
//La fusion executera la callback de promesse qu'après 0.5 seconde
var fusion = function(guy1:Guy,guy2:Guy):Q.IPromise&lt;Guy&gt; {
    var deferred = Q.defer();
	
    setTimeout(() => {
       deferred.resolve(new Guy(guy1.power + guy2.power))
    }, 500);
	
    return deferred.promise;
};
</code></pre>
				</section>

				<section>
					<h3>Exemple</h3>
					<pre><code>
var boo = new Guy(8500);
var goku = new Guy(4000);
var vegeta = new Guy(3500);

var promiseForBejito:Q.IPromise&lt;Guy&gt; = fusion(goku, vegeta);

promiseForBejito.done((bejito:Guy) => {
	// affiche boo, une fois que la fusion est fini
	console.log(fight(bejito, boo)) 
})
					</code></pre>
				</section>

				<section>
					<h3><code>fusion</code> n'est plus une loi de composition interne</h3>
					<p class="fragment">Le type de retour <code>Q.IPromise&lt;Guy&gt;</code> n'est pas le même que celui d'entrée, <code>Guy</code></p>
				</section>

				<section>
					<h3>La lisibilité du <code>reduce</code> en prend un coup</h3>
					<pre><code>
var heroes = [goku, vegeta, goten, trunks];
var promiseForGobejitenks:Q.IPromise&lt;Guy&gt; = heroes.reduce(
    (acc:Q.IPromise&lt;Guy&gt;, guy:Guy) => {
       return acc.then((fusionned) => fusion(fusionned, guy))
    }, Q(new Guy(0))
)

promiseForGobejitenks.done((gobejitenks) => {
    // gobejitenks gagne, après que les fusions aient eu lieues
    // Soit 1.5 secondes
    console.log(fight(gobejitenks, boo)) 
})
					</code></pre>
				</section>

				<section>
					<h3>Retour de la loi de composition interne</h3>
					<pre><code>var fusionPromise = function(guy1:Q.IPromise&lt;Guy&gt;,
                             guy2:Q.IPromise&lt;Guy&gt;):Q.IPromise&lt;Guy&gt; {

    //execute le then quand les 2 promesses sont résolues
    return Q.all([guy1, guy2]).then((guys) =>  fusion(guys[0], guys[1]))
}

var noHero:Q.IPromise&lt;Guy&gt; = Q(new Guy(0));
var heroes = [goku, vegeta, goten, trunks];
var promiseForHeroes:Array&lt;Q.IPromise&lt;Guy&gt;&gt; = heroes.map(Q)

var promiseForGobejitenks = promiseForHeroes.reduce(fusionPromise, noHero)

promiseForGobejitenks.done((gobejitenks) => {
    // gobejitenks gagne, après 1.5 secondes    
    console.log(fight(gobejitenks, boo)) 
})
					</code></pre>
				</section>

				<section>
					<h2>Mais nos heros sont 4</h2>					
					<img src="images/fusionGogeta.gif" />
					<img src="images/fusionGotenks.gif" />
					<aside class="notes">
						On doit pouvoir les faire danser en même temps&nbsp;!, 2 a 2
					</aside>
				</section>

				<section>
					
					
					<h2>Algorithme de parcours en "arbre"</h2>
						<ul>
							<li class="fragment">Si la liste ne contient pas d'élément, on renvoit l'élément neutre</li>
							<li class="fragment">Si la liste contient 1 élément, on renvoit celui-ci</li>
							<li class="fragment">Si la liste contient 2 éléments, on renvoit leur fusion</li>
							<li class="fragment">Si la liste contient plus que 2 éléments, on divise la liste en 2 parts, et on execute l'algorithme ici défini sur chacune des parties, avant de fusionner leurs résultats</li>							
						</ul>

				</section>

				<section>
					<h2>ATTENTION&nbsp;!<br /> Fonction récursive à l'horizon&nbsp;!</h2>
					<pre class="fragment"><code>
var reduceFusion = function(coll:Array&lt;Q.IPromise&lt;Guy&gt;&gt;):Q.IPromise&lt;Guy&gt; {
    var elementsCount = coll.length;
    if(elementsCount == 2) {
        return fusionPromise(coll[0], coll[1]);
    } else if(elementsCount == 1) {
        return fusionPromise[0];
    } else if (elementsCount == 0) {
        return Q(new Guy(0))
    } else {
        var halfSize = elementsCount / 2
        var half1Combined = reduceFusion(coll.slice(0, halfSize));
        var half2Combined = reduceFusion(coll.slice(halfSize, elementsCount));
        return fusionPromise(half1Combined, half2Combined);
    }
};
					</code></pre>
				</section>

				<section>
					<h2>Usage</h2>
					<pre><code>
var promiseForHeroes = [goku, vegeta, goten, trunks].map(Q)
reduceFusion(promiseForHeroes).done((gobejitenks) => {
	//gobejitenks gagne, après seulement 1s, et plus 1.5 s
	console.log(fight(gobejitenks, boo)) 
})
					</code></pre>
				</section>

				<section>
					<h2>Que s'est il passé&nbsp;?</h2>
					<img src="images/fusionTree.png" />
				</section>

				<section>
					<h2>Que fallait-il pour pouvoir paralléliser&nbsp;?</h2>
					<ul>
						<li class="fragment">Une loi de composition interne...</li>
						<li class="fragment">... associative...</li>
						<li class="fragment">... avec un élément neutre</li>
					</ul>
					<p class="fragment">On retrouve notre monoïde</p>
				</section>

				<section>
					<h2>Abstraction du type Monoïde</h2>
					<pre><code>
interface Monoid&lt;T&gt; {
    ZERO:T; //element neutre
    combine:(a:T, b:T) => T //loi de composition interne
}
</code></pre>
				<aside class="notes">Le système de type ne permet pas d'indiquer l'associativité</aside>
				</section>

				<section>
					<h2><code>reduce</code>, parallélisation et monoïde</h2>
					<pre><code>
var reduceMonoid = function&lt;T&gt;(m:Monoid&lt;T&gt;, coll:Array&lt;T&gt;):T {
    var elementsCount = coll.length;
    if(elementsCount == 2) {
        return m.combine(coll[0], coll[1]);
    } else if(elementsCount == 1) {
        return coll[0];
    } else if (elementsCount == 0) {
        return m.ZERO
    } else {
        var halfSize = elementsCount / 2
        var firstHalf = reduceMonoid(m, coll.slice(0, halfSize));
        var secondHalf = reduceMonoid(m, coll.slice(halfSize, elementsCount));
        return m.combine(firstHalf, secondHalf);
    }
};
					</code></pre>
				</section>

				<section>
					<h2><code>fusion</code> et <code>reduceMonoid</code></h2>
				<pre><code>
var monoidOfPromiseOfGuy:Monoid&lt;Q.IPromise&lt;Guy&gt;&gt; = {
		ZERO: Q(new Guy(0)),
		combine: fusionPromise
};

var promiseForHeroes = [goku,vegeta, goten, trunsk].map(Q)
var promiseForGobejitenks = 
        reduceMonoid(monoidOfPromiseOfGuy, promiseForHeroes);

					</code></pre>
				</section>

				<section>
					<h4>Mais,</h4>
					<h3 class="fragment"> quand on commence à penser monoïde,</h3>
					<h2 class="fragment"> on en voit partout</h2>
					<pre class="fragment"><code>
var monoidOfBetterGuy: Monoid&lt;Guy&gt; = {
    ZERO:new Guy(0),
    combine:fight
}
var heroes = [goku,vegeta, boo, goten, trunks]
var winnerOfBattleRoyale = 
	reduceMonoid(monoidOfBetterGuy, heroes) // renvoit boo
					</code></pre>
				</section>

				<section>
					<h3><code>fight</code> est bien une loi de composition interne,<br /> associative, avec un élément neutre</h3>
					<pre><code>
var fight = function (guy1:Guy, guy2:Guy):Guy {	
	return guy1.power > guy2.power ? guy1 : guy2
}

var mrSatan = new Guy(0);

//vaut true
fight(goku,fight(boo, vegeta)).equals(fight(fight(goku, boo), vegeta))

fight(goku, mrSatan).equal(goku) // vaut true
fight(mrSatan, goku).equal(goku) // vaut true
					</code></pre>
				</section>

				<section>
					<h1>Au fond,</h1>
					<h1> vous en utilisez tous les jours,</h1>
					<h1> des monoïdes</h1>
				</section>

				<section>
					<h2>Quelques exemples</h2>
					<p>(ensemble, opération, élément neutre)</p>
					<ul>
						<li class="fragment">(number, +, 0)</li>
						<li class="fragment"> (number, *, 1)</li>
						<li class="fragment"> (number positif, max, 0)</li>
						<li class="fragment"> (string, +, '')</li>
						<li class="fragment"> (Array, concat, [])</li>
						<li class="fragment"> (Promise<T>, Q.all, Q)</li>
					</ul>
				</section>

				<section>
					<h1>Construction de monoïde à partir d'un autre</h1>
				</section>

				<section>
					<h2>Wrapping</h2>
					<pre><code>
	//exemple de monoide :
	{
	    ZERO: new Guy(0),
	    combine: (a, b) => new Guy(a.power + b.power)
	};

	{
	    ZERO: new Guy(1),
	    combine: (a, b) => new Guy(a.power * b.power)
	};
					</code></pre>
				</section>

				<section>
					<h2>Composition</h2>
					<pre><code>

class Guy {
    constructor(public power:number, public name:string) {}
} 

//exemple de monoide :
{
    ZERO: new Guy(0, ""),
    combine: (a, b) => new Guy(a.power + b.power, a.name + b.name)
};
					</code></pre>
				</section>

				<section>
					<h2>Monades</h2>
					<pre><code>
{
		ZERO: Some(0),
		combine: (a:Option&lt;number&gt;, b:Option&lt;number&gt;) => {
		    return a.flatMap(c => b.map( d => c + d))
		}
}
					</code></pre>
				</section>

				<section>
					<h2>Promesses</h2>
					<pre><code>
{
		ZERO: Q(0),
		combine: (a:Q.IPromise&lt;number&gt;, b:Q.IPromise&lt;number&gt;) => {
		    return Q.all([a,b]).then( list => list[0] + list[1] )
		}
}
					</code></pre>
				</section>

				<section>
					<h2>Soyons pédant&nbsp;:</h2>
					<h2 class="fragment"> en fait ca marche pour tous les morphismes de monoide</h2>					
				</section>

				<section>
					<h3>Certains langages sont plus adaptés que d'autres à l'utilisation de ce genre d'abstraction</h3>
					<ul>
						<li class="fragment">Haskell possède un type natif Monoid</li>
						<li class="fragment">Scalaz propose un type Monoid pour Scala</li>						
						<li class="fragment">Et même PHPZ pour PHP&nbsp;!</li>  

					</ul>
					
				</section>

				<section>
					<h3>En conclusion - le monoide</h3>
					<ul>
						<li class="fragment">Lisibilité</li>
						<li class="fragment">Parcours sous forme d'arbre</li>
						<li class="fragment">Parallélisation</li>
					</ul>
				</section>

				<section>
					<h3>En conclusion - les mathématiques</h3>
					<ul>
						<li class="fragment">Les gros mots des matheux couvrent des abstractions</li>
						<li class="fragment">Comme en programmation, les abstractions permettent la réutilisabilité</li>
						<li class="fragment">Ces abstractions imposent des contrats aux ensembles auxquels elles s'appliquent...</li>
						<li class="fragment">... comme nos interfaces</li>
						<li class="fragment">Il est donc intéressant de s'y plonger, pour ne pas réinventer la roue</li>
					</ul>
				</section>

				<section>
					<h3>Des questions&nbsp;?</h3>
					<img src="images/buuHappy.jpg" />
				</section>

			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

				// Parallax scrolling
				// parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
				// parallaxBackgroundSize: '2100px 900px',

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>
